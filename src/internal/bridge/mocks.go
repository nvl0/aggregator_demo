// Code generated by MockGen. DO NOT EDIT.
// Source: ../internal/bridge/interface.go
//
// Generated by this command:
//
//	mockgen -destination=../internal/bridge/mocks.go -package=bridge -source=../internal/bridge/interface.go
//

// Package bridge is a generated GoMock package.
package bridge

import (
	channel "aggregator/src/internal/entity/channel"
	session "aggregator/src/internal/entity/session"
	traffic "aggregator/src/internal/entity/traffic"
	transaction "aggregator/src/internal/transaction"
	reflect "reflect"
	sync "sync"

	gomock "go.uber.org/mock/gomock"
)

// MockFlow is a mock of Flow interface.
type MockFlow struct {
	ctrl     *gomock.Controller
	recorder *MockFlowMockRecorder
}

// MockFlowMockRecorder is the mock recorder for MockFlow.
type MockFlowMockRecorder struct {
	mock *MockFlow
}

// NewMockFlow creates a new mock instance.
func NewMockFlow(ctrl *gomock.Controller) *MockFlow {
	mock := &MockFlow{ctrl: ctrl}
	mock.recorder = &MockFlowMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFlow) EXPECT() *MockFlowMockRecorder {
	return m.recorder
}

// PrepareFlow mocks base method.
func (m *MockFlow) PrepareFlow(dirName string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrepareFlow", dirName)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PrepareFlow indicates an expected call of PrepareFlow.
func (mr *MockFlowMockRecorder) PrepareFlow(dirName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareFlow", reflect.TypeOf((*MockFlow)(nil).PrepareFlow), dirName)
}

// MockSession is a mock of Session interface.
type MockSession struct {
	ctrl     *gomock.Controller
	recorder *MockSessionMockRecorder
}

// MockSessionMockRecorder is the mock recorder for MockSession.
type MockSessionMockRecorder struct {
	mock *MockSession
}

// NewMockSession creates a new mock instance.
func NewMockSession(ctrl *gomock.Controller) *MockSession {
	mock := &MockSession{ctrl: ctrl}
	mock.recorder = &MockSessionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSession) EXPECT() *MockSessionMockRecorder {
	return m.recorder
}

// LoadOnlineSessionMap mocks base method.
func (m *MockSession) LoadOnlineSessionMap(ts transaction.Session) (map[session.NasIP][]session.OnlineSession, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadOnlineSessionMap", ts)
	ret0, _ := ret[0].(map[session.NasIP][]session.OnlineSession)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadOnlineSessionMap indicates an expected call of LoadOnlineSessionMap.
func (mr *MockSessionMockRecorder) LoadOnlineSessionMap(ts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadOnlineSessionMap", reflect.TypeOf((*MockSession)(nil).LoadOnlineSessionMap), ts)
}

// MockChannel is a mock of Channel interface.
type MockChannel struct {
	ctrl     *gomock.Controller
	recorder *MockChannelMockRecorder
}

// MockChannelMockRecorder is the mock recorder for MockChannel.
type MockChannelMockRecorder struct {
	mock *MockChannel
}

// NewMockChannel creates a new mock instance.
func NewMockChannel(ctrl *gomock.Controller) *MockChannel {
	mock := &MockChannel{ctrl: ctrl}
	mock.recorder = &MockChannelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChannel) EXPECT() *MockChannelMockRecorder {
	return m.recorder
}

// LoadChannelMap mocks base method.
func (m *MockChannel) LoadChannelMap(ts transaction.Session) (map[channel.ChannelID]bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadChannelMap", ts)
	ret0, _ := ret[0].(map[channel.ChannelID]bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadChannelMap indicates an expected call of LoadChannelMap.
func (mr *MockChannelMockRecorder) LoadChannelMap(ts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadChannelMap", reflect.TypeOf((*MockChannel)(nil).LoadChannelMap), ts)
}

// MockTraffic is a mock of Traffic interface.
type MockTraffic struct {
	ctrl     *gomock.Controller
	recorder *MockTrafficMockRecorder
}

// MockTrafficMockRecorder is the mock recorder for MockTraffic.
type MockTrafficMockRecorder struct {
	mock *MockTraffic
}

// NewMockTraffic creates a new mock instance.
func NewMockTraffic(ctrl *gomock.Controller) *MockTraffic {
	mock := &MockTraffic{ctrl: ctrl}
	mock.recorder = &MockTrafficMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTraffic) EXPECT() *MockTrafficMockRecorder {
	return m.recorder
}

// CountTraffic mocks base method.
func (m *MockTraffic) CountTraffic(oldTraffic map[channel.ChannelID]traffic.Traffic, newTraffic traffic.Traffic, channelMap map[channel.ChannelID]bool, channelID channel.ChannelID) map[channel.ChannelID]traffic.Traffic {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountTraffic", oldTraffic, newTraffic, channelMap, channelID)
	ret0, _ := ret[0].(map[channel.ChannelID]traffic.Traffic)
	return ret0
}

// CountTraffic indicates an expected call of CountTraffic.
func (mr *MockTrafficMockRecorder) CountTraffic(oldTraffic, newTraffic, channelMap, channelID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountTraffic", reflect.TypeOf((*MockTraffic)(nil).CountTraffic), oldTraffic, newTraffic, channelMap, channelID)
}

// ParseFlow mocks base method.
func (m *MockTraffic) ParseFlow(channelMap map[channel.ChannelID]bool, flow string) (map[session.IP]map[channel.ChannelID]traffic.Traffic, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ParseFlow", channelMap, flow)
	ret0, _ := ret[0].(map[session.IP]map[channel.ChannelID]traffic.Traffic)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ParseFlow indicates an expected call of ParseFlow.
func (mr *MockTrafficMockRecorder) ParseFlow(channelMap, flow any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParseFlow", reflect.TypeOf((*MockTraffic)(nil).ParseFlow), channelMap, flow)
}

// SiftTraffic mocks base method.
func (m *MockTraffic) SiftTraffic(channelMap map[channel.ChannelID]bool, trafficMap map[session.IP]map[channel.ChannelID]traffic.Traffic, sessionList []session.OnlineSession) ([]session.Chunk, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SiftTraffic", channelMap, trafficMap, sessionList)
	ret0, _ := ret[0].([]session.Chunk)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SiftTraffic indicates an expected call of SiftTraffic.
func (mr *MockTrafficMockRecorder) SiftTraffic(channelMap, trafficMap, sessionList any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SiftTraffic", reflect.TypeOf((*MockTraffic)(nil).SiftTraffic), channelMap, trafficMap, sessionList)
}

// MockAggregator is a mock of Aggregator interface.
type MockAggregator struct {
	ctrl     *gomock.Controller
	recorder *MockAggregatorMockRecorder
}

// MockAggregatorMockRecorder is the mock recorder for MockAggregator.
type MockAggregatorMockRecorder struct {
	mock *MockAggregator
}

// NewMockAggregator creates a new mock instance.
func NewMockAggregator(ctrl *gomock.Controller) *MockAggregator {
	mock := &MockAggregator{ctrl: ctrl}
	mock.recorder = &MockAggregatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregator) EXPECT() *MockAggregatorMockRecorder {
	return m.recorder
}

// Aggregate mocks base method.
func (m *MockAggregator) Aggregate(wg *sync.WaitGroup, nasIP string, sessionList []session.OnlineSession, channelMap map[channel.ChannelID]bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Aggregate", wg, nasIP, sessionList, channelMap)
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockAggregatorMockRecorder) Aggregate(wg, nasIP, sessionList, channelMap any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*MockAggregator)(nil).Aggregate), wg, nasIP, sessionList, channelMap)
}
